'use strict';

exports.__esModule = true;
exports.getCompositeAggsQuery = exports.getAggsQuery = exports.updateInternalQuery = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _reactivecore = require('@appbaseio/reactivecore');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var getAggsOrder = _reactivecore.helper.getAggsOrder,
    getOptionsFromQuery = _reactivecore.helper.getOptionsFromQuery;

/**
 * Updates the query for the internal component
 */

var updateInternalQuery = exports.updateInternalQuery = function updateInternalQuery(componentId, queryOptions, value, props, defaultQueryToExecute, queryParams) {
	var defaultQuery = props.defaultQuery;

	var defaultQueryOptions = void 0;
	var query = void 0;
	if (defaultQuery) {
		var queryTobeSet = defaultQuery(value, props);

		var _ref = queryTobeSet || {};

		query = _ref.query;

		defaultQueryOptions = getOptionsFromQuery(queryTobeSet);
	}
	props.setQueryOptions(componentId, _extends({}, defaultQueryOptions, queryOptions || defaultQueryToExecute));
	if (query) {
		props.updateQuery(_extends({
			componentId: componentId,
			query: query
		}, queryParams));
	}
};
// extracts query options from defaultQuery if set
var extractQueryFromDefaultQuery = function extractQueryFromDefaultQuery(defaultQuery) {
	var queryToBeReturned = {};
	if (defaultQuery) {
		var evaluateQuery = defaultQuery();
		if (evaluateQuery) {
			// we should only retrieve and set the query options here.
			// [Not implemented yet] `query` key should be handled separately for
			// adding it to `queryList` in the redux store
			var query = evaluateQuery.query,
			    options = _objectWithoutProperties(evaluateQuery, ['query']);

			if (options) {
				queryToBeReturned = options;
			}
		}
	}
	return queryToBeReturned;
};

var getAggsQuery = function getAggsQuery(query, props) {
	var _clonedQuery$aggs;

	var clonedQuery = query;
	var dataField = props.dataField,
	    size = props.size,
	    sortBy = props.sortBy,
	    showMissing = props.showMissing,
	    missingLabel = props.missingLabel;

	clonedQuery.size = 0;
	clonedQuery.aggs = (_clonedQuery$aggs = {}, _clonedQuery$aggs[dataField] = {
		terms: _extends({
			field: dataField,
			size: size,
			order: getAggsOrder(sortBy || 'count')
		}, showMissing ? { missing: missingLabel } : {})
	}, _clonedQuery$aggs);

	if (props.nestedField) {
		clonedQuery.aggs = {
			reactivesearch_nested: {
				nested: {
					path: props.nestedField
				},
				aggs: clonedQuery.aggs
			}
		};
	}
	return _extends({}, clonedQuery, extractQueryFromDefaultQuery(props.defaultQuery));
};

var getCompositeAggsQuery = function getCompositeAggsQuery(query, props, after) {
	var _ref2, _clonedQuery$aggs2;

	var clonedQuery = query;
	// missing label not available in composite aggs
	var dataField = props.dataField,
	    size = props.size,
	    sortBy = props.sortBy,
	    showMissing = props.showMissing;

	// composite aggs only allows asc and desc

	var order = sortBy === 'count' ? {} : { order: sortBy };

	clonedQuery.aggs = (_clonedQuery$aggs2 = {}, _clonedQuery$aggs2[dataField] = {
		composite: _extends({
			sources: [(_ref2 = {}, _ref2[dataField] = {
				terms: _extends({
					field: dataField
				}, order, showMissing ? { missing_bucket: true } : {})
			}, _ref2)],
			size: size
		}, after)
	}, _clonedQuery$aggs2);
	clonedQuery.size = 0;

	if (props.nestedField) {
		clonedQuery.aggs = {
			reactivesearch_nested: {
				nested: {
					path: props.nestedField
				},
				aggs: clonedQuery.aggs
			}
		};
	}
	return _extends({}, clonedQuery, extractQueryFromDefaultQuery(props.defaultQuery));
};

exports.getAggsQuery = getAggsQuery;
exports.getCompositeAggsQuery = getCompositeAggsQuery;